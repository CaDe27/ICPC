#include<bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;
//https://omegaup.com/arena/problem/Loca-People#problems

const int MAXN = 1002;

int n, m;
int A[MAXN][MAXN]; // Matriz original
int h[MAXN][MAXN]; // La altura del "edificio" en (i,j)

// Esta función regresa el área máxima de algún rectángulo
// que tiene base en la fila j y techo en la fila i
int maxAreaConBaseYTecho_[MAXN][MAXN];
int maxAreaConBaseYTecho(int i, int j) {
  if (i > j) return 0;
  if (maxAreaConBaseYTecho_[i][j] == -1) {
    // Construimos todo el piso j para cualquier i con la
    // idea de destruyendo edificios
    stack <pii> pila;
    auto arr = h[j];
    int maxAncho[n+2];               // maxAncho[h] te dice cual es el ancho
    fill(maxAncho, maxAncho+n+2, 0); // del efificio más ancho de altura h

    // Esta función mete a la pila el edificio de altura x
    auto mete = [&pila, &maxAncho](int x) {
      int cnt = 0; // Cuántos me he comido
      while (!pila.empty() && pila.top().first >= x) {
        // Al hacer pop, ya podemos calcular el ancho del
        // elemento top de la pila
        auto h_ = pila.top().first;
        auto v_ = pila.top().second;
        maxAncho[h_] = max(maxAncho[h_], v_+cnt+1);
        // Procedo a comer el edificio
        cnt += v_+1;
        pila.pop();
      }
      pila.push({x, cnt});
    };

    for (int l = 1; l <= m; ++l) {
      // Estamos metiendo el elemento h[j][l]
      mete(arr[l]);
    }
    mete(0); // Para "vaciar" la pila

    // Propagamos maxAncho para que si puedo formar un
    // edificio de altura h y ancho v, pueda también
    // formar edificio de altura h-1 y ancho v
    for (int k = n; k >= 0; --k)
      maxAncho[k] = max(maxAncho[k], maxAncho[k+1]);

    // Ya tenemos bien calculado maxAncho, entonces
    // podemos calcular ya maxAreaConBaseYTecho
    for (int l = 1; l <= j; ++l) {
      int h_ = j-l+1;
      maxAreaConBaseYTecho_[l][j] = h_ * maxAncho[h_];
    }
  }
  return maxAreaConBaseYTecho_[i][j];
}

// Esta función regresa el área máxima de algún rectángulo formado
// por 1s que tenga base en la fila j y no exceda la fila i
int maxAreaEntreFilaConBase_[MAXN][MAXN];
int maxAreaEntreFilaConBase(int i, int j) {
  if (i > j) return 0;
  if (maxAreaEntreFilaConBase_[i][j] == -1) {
    // El rectángulo con base en la fila j que se extienda
    // a lo más hasta la fila i de área máxima está
    // en un rectángulo con base en fila j que se extienda
    // a lo más hasta la fila i-1 o en un rectángulo con
    // base en la fila j y techo en la fila i
    maxAreaEntreFilaConBase_[i][j] = max(
    	maxAreaConBaseYTecho(i, j),
      maxAreaEntreFilaConBase(i+1, j)
    );
  }
  return maxAreaEntreFilaConBase_[i][j];
}

// Esta función regresa el área máxima de algun rectángulo formado
// únicamente por 1s entre las filas i, j inclusive
int maxAreaEntreFilas_[MAXN][MAXN];
int maxAreaEntreFilas(int i, int j) {
  if (i > j) return 0;
  if (maxAreaEntreFilas_[i][j] == -1) {
    // El rectángulo que maximiza el area está entre las filas
    // [i, j-1] o es un rectángulo tal que su base toca la fila j
    maxAreaEntreFilas_[i][j] = max(
      maxAreaEntreFilas(i, j-1),
      maxAreaEntreFilaConBase(i, j)
    );
  }
  return maxAreaEntreFilas_[i][j];
}

void init() {
  // Iniciamos las matrices que guardan las dps en -1
  for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= m; ++j) {
    maxAreaEntreFilas_[i][j] = -1;
    maxAreaEntreFilaConBase_[i][j] = -1;
    maxAreaConBaseYTecho_[i][j] = -1;
  }
}

int main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  if(fopen("case.in","r")) freopen("case.in","r",stdin);
  cin >> n >> m;
  init();
  // Leemos la matriz y calculamos h
  for (int i = 1; i <= n; ++i)
  for (int j = 1; j <= m; ++j) {
    cin >> A[i][j];
    h[i][j] = A[i][j] ? h[i-1][j]+1 : 0;
  }

  int Q;
  cin >> Q;
  // Procesamos las queries
  for (int q = 1; q <= Q; ++q) {
    int a, b;
    cin >> a >> b;
    cout << maxAreaEntreFilas(a, b) << "\n";
  }

  return 0;
}